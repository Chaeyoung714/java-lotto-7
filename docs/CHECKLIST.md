# 과제 기본 요구사항 체크리스트
> 과제 페이지에 명시된 기본 요구사항을 반영한 체크리스트입니다.
## ✅ 학습 목표
- [ ]  관련 함수를 묶어 클래스를 만들고, 객체들이 협력하여 하나의 큰 기능을 수행하도록 한다.
- [ ]  클래스/함수에 대한 단위테스트를 통해 의도한대로 정확하게 작동하는 영역을 확보한다.
- [ ]  2주차 공통 피드백을 최대한 반영한다.

## ✅ 과제 진행 요구 사항
- [ ]  기능을 구현하기 전 README.md에 구현할 기능 목록을 정리해 추가한다.
- [ ]  README.md의 기능목록 단위로 커밋한다.

## ✅ 프로그래밍 요구 사항

- [ ]  JDK21 버전에서 실행 가능하다
- [ ]  build.gradle 파일을 변경하지 않는다.
- [ ]  프로그램 종료 시 `System.exit()`를 호출하지 않는다.
- [ ]  프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다.
- [ ]  자바 코드 컨벤션을 지키면서 프로그래밍한다.
- [ ]  인덴트 뎁스를 2까지만 구현한다.
- [ ]  3항 연산자를 쓰지 않는다.
- [ ]  메서드가 한 가지 일만 하도록 최대한 작게 만든다.
- [ ]  JUnit 5와 AssertJ를 이용하여 정리한 기능 목록이 정상적으로 작동하는지 테스트 코드로 확인한다.
- [ ]  메서드의 길이가 15라인을 넘어가지 않도록 구현한다.
- [ ]  else 예약어, switch/case를 사용하지 않는다.
- [ ]  Java Enum을 적용한다.
- [ ]  구현한 기능에 대한 단위 테스트를 작성한다. 단, UI(`System.out`,`System.in`, `Scanner`) 로직은 제외한다.
- [ ]  제공된 Lotto 클래스를 사용하여 구현한다.
    - [ ]  `Lotto`에 `numbers`이외의 필드(인스턴스 변수)를 추가하지 않는다.
    - [ ]  `numbers`의 접근 제어자인`private`은 변경하지 않는다.


## ✅ 2주차 공통피드백

- [ ]  README를 작성할 때 프로젝트의 소개를 목적으로 상세히 작성한다.
- [ ]  기능 목록에 기술적인 내용은 배제한다.
- [ ]  기능 목록에 정상적인 경우와 예외상황을 모두 명시한다.
- [ ]  기능 목록을 지속적으로 업데이트한다.
- [ ]  문자열이나 숫자 값을 하드 코딩하지 않는다.
- [ ]  상수-멤버변수-생성자-메서드 순의 코딩 컨벤션을 지키고, 메서드는 논리적인 이유로 정렬한다.
- [ ]  변수 이름에 자료형을 사용하지 않는다.
- [ ]  한 메서드가 한 가지 기능만 담당하게 한다.
- [ ]  메서드가 한 가지 기능을 하는지 확인하는 나만의 기준을 만든다.
- [ ]  학습테스트를 통해 JUnit을 학습한다.
- [ ]  테스트를 작성하는 이유에 대해 정리하고 디스코드에 공유해본다.
- [ ]  테스트를 메서드 등의 작은 단위부터 만든다.

<br>

---

# 개인 체크리스트
> 1주차~2주차의 개선점을 바탕으로 세운 개인적인 목표를 반영한 체크리스트입니다.

## 🏁 과제 전반 체크리스트

- [ ]  `과제의 기본 요구사항 충족`을 최우선으로 1차 구현`한다.
- [ ]  `학습목표 충족`을 최우선으로 리팩토링한다.
- [ ]  1주차, 2주차 공통피드백을 모두 충족시킨다.
- [ ]  “~이 좋다더라”, “~하면 안된다더라” 와 같은 **단정짓는 생각을 지양하고 상황에 따른 판단을 한다.**
- [ ]  **책임을 최대한 섬세하게 나누되, 각각의 클래스와 메서드의 역할이 분명하도록 한다.**
- [ ]  `스태틱 메서드`와 `싱글톤 패턴`을 구분해서 사용한다.
- [ ]  읽는 사람이 `두 번 생각하게 하는 로직은 지양`한다.
- [ ]  작은 것이라도 `축약하지 않는다`.
- [ ]  조건문에 `부정연산자 사용을 지양`한다.
- [ ]  `주석을 사용하지 않는다`. 사용할 상황이어도 최대한 코드를 활용해 문서화한다.

## 📑 문서 체크리스트

- [ ]  리드미에 기능구현목록 뿐만 아니라 `프로젝트 소개`도 작성하여 프로젝트를 잘 드러낸다.
- [ ]  `리드미`와 `체크리스트`를 분리해서 작성한다.
- [ ]  리드미를 수정할 일이 있다면 `변경 이력`을 함께 작성한다.

## 🛠️ 리팩토링 체크리스트

- [ ]  1차 구현 이후, `일급 개념`이 어떤 것이 될 수 있는지 체크한다.
- [ ]  1차 구현 이후, 클래스다이어그램을 사용해 `상속, 구현, 의존, 연관, 합성관계`를 표시한다.
- [ ]  리팩토링 시 `관련 함수를 묶어` 클래스를 만들고, `객체들이 협력하여` 하나의 큰 기능을 수행하도록 한다.
- [ ]  **리팩토링 구현 과정에서 진행이 어렵다면, 항상 책임 분리를 더 할 수 있는지 체크한다.**
- [ ]  `의존성`이 발생할 때마다 `추상화`를 고려한다. 이후 추상화를 하면 `의존성 주입`을 고려한다.
- [ ]  `인터페이스`를 적절한 위치에 도입하고, `도입한 이유를 말로 설명한다`.
- [ ]  그 외에도 새로운 패턴, 로직을 도입할 땐 `도입한 이유를 말로 설명한다`.

## 🩺 검증로직 체크리스트

- [ ]  검증이 가능한 시점(뷰or도메인)에서 `바로 검증`한다
- [ ]  도메인단에서 검증할 경우 `도메인 내에서` 검증 여부가 확인되도록 한다

## 🧪 테스트 체크리스트

- [ ]  TDD로 테스트를 개발에 이용한다. 매번 기능을 만들고 `테스트를 통과한 뒤에 다음 구현으로 넘어간다`.
- [ ]  테스트 구현 과정에서 `제어할 수 없는 요소`가 발생해 진행이 어렵다면, 항상 `책임 분리`를 더 할 수 있는지 체크한다.
- [ ]  변수명, 상수 활용 등을 통해서 테스트 케이스로 사용한 문자열, 넘버 역시 `의미를 최대한 표현`한다.
- [ ]  DisplayName을 사용하여 `테스트의 문서화`를 강화한다.
- [ ]  중복되는 로직은 `리팩토링`한다.
- [ ]  모든 `퍼블릭 메서드와 클래스`를 테스트대상으로 한다.